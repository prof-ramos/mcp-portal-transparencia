{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Repository and Structure",
        "description": "Initialize the project repository with proper structure, configuration files, and development environment setup for the MCP Portal da Transparência API.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "✅ TASK COMPLETED - Comprehensive Project Setup and Configuration\n\n**All components successfully implemented:**\n\n1. **✅ GitHub Repository Setup**\n   - Git repository initialized on main branch\n   - Initial commit created with comprehensive project structure\n   - README.md with detailed project documentation and usage examples\n\n2. **✅ Package Management Configuration**\n   - Enhanced package.json with comprehensive metadata and scripts\n   - Production dependencies: axios, swagger-parser, openapi-typescript, winston, dotenv\n   - Development dependencies: TypeScript toolchain, ESLint/Prettier, Jest, Rollup, etc.\n   - Dual module format support (CommonJS + ESM)\n   - All dependencies successfully installed\n\n3. **✅ TypeScript Configuration**\n   - Comprehensive tsconfig.json with modern ES2020 target\n   - Path aliases configured for clean imports (@/clients, @/core, etc.)\n   - Strict typing enabled with additional safety checks\n   - Build configuration for dist/ output\n\n4. **✅ ESLint and Prettier Setup**\n   - Modern ESLint flat config with TypeScript integration\n   - Prettier configuration for consistent code formatting\n   - Pre-commit hooks configured with husky and lint-staged\n   - All code quality checks passing\n\n5. **✅ Folder Structure Created**\n   ```\n   src/\n     ├── clients/       # Generated API clients\n     ├── core/          # Core MCP functionality  \n     ├── utils/         # Utility functions\n     ├── types/         # TypeScript interfaces\n     ├── config/        # Configuration\n     ├── errors/        # Error handling\n     ├── logging/       # Logging functionality\n     └── index.ts       # Main entry point\n   tests/\n     ├── unit/          # Unit tests\n     └── integration/   # Integration tests\n   docs/\n     └── examples/      # Usage examples\n   ```\n\n6. **✅ Jest Testing Setup**\n   - Jest configured with ts-jest for TypeScript support\n   - Coverage reporting configured\n   - Sample test created and passing\n   - Multiple test scripts available (test, test:watch, test:coverage)\n\n7. **✅ Build System (Rollup)**\n   - Multi-format builds: CommonJS, ESM, and minified ESM\n   - TypeScript declaration files generated\n   - Source maps enabled for debugging\n   - Build process verified and working\n\n8. **✅ GitHub Actions CI/CD Pipeline**\n   - Comprehensive workflow with matrix testing (Node 16, 18, 20)\n   - Automated testing, linting, and building\n   - Automatic NPM publishing on version changes\n   - GitHub releases creation\n   - Code coverage reporting to Codecov\n\n**Generated Build Artifacts:**\n- dist/index.js (CommonJS build)\n- dist/index.esm.js (ESM build) \n- dist/index.esm.min.js (Minified ESM)\n- dist/index.d.ts (TypeScript declarations)\n- Source maps for all builds\n\nThe project foundation is now complete and ready for implementing the MCP functionality. All development tools, build processes, and CI/CD pipelines are fully operational.",
        "testStrategy": "✅ ALL VERIFICATION TESTS PASSED:\n1. ✅ TypeScript compilation: `npm run typecheck` - no errors\n2. ✅ Jest tests: `npm test` - all tests passing\n3. ✅ Build process: `npm run build` - all formats generated successfully\n4. ✅ ESLint runs without errors\n5. ✅ Project structure: All directories and configuration files in place\n6. ✅ GitHub Actions CI/CD pipeline operational\n7. ✅ Code quality checks passing with pre-commit hooks",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Swagger Spec Loader",
        "description": "Create a module to load, parse, and validate the Swagger specification from the Portal da Transparência API.",
        "details": "1. Install required dependencies:\n   - `npm install axios swagger-parser @apidevtools/swagger-parser openapi-types --save`\n2. Create a SwaggerLoader class in `src/core/swagger-loader.ts`:\n```typescript\nimport axios from 'axios';\nimport SwaggerParser from '@apidevtools/swagger-parser';\nimport { OpenAPI } from 'openapi-types';\nimport { Logger } from '../logging/logger';\n\nexport class SwaggerLoader {\n  private specUrl: string;\n  private cachedSpec: OpenAPI.Document | null = null;\n  private logger: Logger;\n\n  constructor(specUrl: string = 'https://api.portaldatransparencia.gov.br/v3/api-docs', logger: Logger) {\n    this.specUrl = specUrl;\n    this.logger = logger;\n  }\n\n  async loadSpec(): Promise<OpenAPI.Document> {\n    try {\n      this.logger.info('Loading Swagger specification', { url: this.specUrl });\n      const response = await axios.get(this.specUrl);\n      const rawSpec = response.data;\n      \n      // Validate the spec\n      const validatedSpec = await SwaggerParser.validate(rawSpec) as OpenAPI.Document;\n      this.cachedSpec = validatedSpec;\n      this.logger.info('Swagger specification loaded successfully');\n      return validatedSpec;\n    } catch (error) {\n      this.logger.error('Failed to load Swagger specification', { error });\n      throw new Error(`Failed to load Swagger specification: ${error.message}`);\n    }\n  }\n\n  async getSpec(): Promise<OpenAPI.Document> {\n    if (!this.cachedSpec) {\n      return this.loadSpec();\n    }\n    return this.cachedSpec;\n  }\n\n  async detectSpecChanges(newSpecUrl?: string): Promise<boolean> {\n    const currentSpec = await this.getSpec();\n    const newSpec = await new SwaggerLoader(newSpecUrl || this.specUrl, this.logger).loadSpec();\n    \n    // Compare versions or other relevant properties\n    return currentSpec.info.version !== newSpec.info.version;\n  }\n}\n```\n3. Create a simple spec validator to check for required fields and structure\n4. Implement caching mechanism to avoid unnecessary reloads\n5. Add version detection to identify API changes",
        "testStrategy": "1. Unit tests:\n   - Test loading spec from a mock URL\n   - Test caching mechanism\n   - Test error handling for invalid URLs\n   - Test version comparison logic\n2. Integration tests:\n   - Test loading the actual Portal da Transparência Swagger spec\n   - Verify all expected endpoints are present\n   - Test version detection with actual API",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Logging System",
        "description": "Create a structured logging system that outputs JSON logs and captures API call details, errors, and performance metrics.",
        "details": "1. Install logging dependencies:\n   - `npm install pino pino-pretty --save`\n2. Create a Logger class in `src/logging/logger.ts`:\n```typescript\nimport pino from 'pino';\n\nexport interface LoggerOptions {\n  level?: string;\n  prettyPrint?: boolean;\n}\n\nexport class Logger {\n  private logger: pino.Logger;\n\n  constructor(options: LoggerOptions = {}) {\n    this.logger = pino({\n      level: options.level || 'info',\n      ...(options.prettyPrint ? { transport: { target: 'pino-pretty' } } : {}),\n    });\n  }\n\n  info(message: string, data?: Record<string, any>): void {\n    this.logger.info(data || {}, message);\n  }\n\n  error(message: string, data?: Record<string, any>): void {\n    // Ensure API keys are not logged\n    if (data?.headers?.['chave-api-portal']) {\n      data.headers['chave-api-portal'] = '[REDACTED]';\n    }\n    this.logger.error(data || {}, message);\n  }\n\n  warn(message: string, data?: Record<string, any>): void {\n    this.logger.warn(data || {}, message);\n  }\n\n  debug(message: string, data?: Record<string, any>): void {\n    this.logger.debug(data || {}, message);\n  }\n\n  // Specialized method for API calls\n  logApiCall({\n    endpoint,\n    method,\n    requestPayload,\n    responseStatus,\n    responseTime,\n    error,\n  }: {\n    endpoint: string;\n    method: string;\n    requestPayload?: any;\n    responseStatus?: number;\n    responseTime?: number;\n    error?: Error;\n  }): void {\n    const logData = {\n      endpoint,\n      method,\n      requestPayload: this.sanitizePayload(requestPayload),\n      responseStatus,\n      responseTime,\n      error: error ? { message: error.message, stack: error.stack } : undefined,\n    };\n\n    if (error) {\n      this.error('API call failed', logData);\n    } else {\n      this.info('API call completed', logData);\n    }\n  }\n\n  private sanitizePayload(payload: any): any {\n    if (!payload) return payload;\n    \n    // Deep clone to avoid modifying the original\n    const sanitized = JSON.parse(JSON.stringify(payload));\n    \n    // Redact sensitive fields\n    if (sanitized.apiKey) sanitized.apiKey = '[REDACTED]';\n    if (sanitized['chave-api-portal']) sanitized['chave-api-portal'] = '[REDACTED]';\n    \n    return sanitized;\n  }\n}\n```\n3. Create a LoggerFactory to ensure consistent logger instances across the application\n4. Implement log rotation for production environments\n5. Add context tracking to correlate logs from the same request flow",
        "testStrategy": "1. Unit tests:\n   - Test log level filtering\n   - Test sensitive data redaction\n   - Test JSON formatting\n   - Test API call logging format\n2. Integration tests:\n   - Verify logs are correctly written to files\n   - Test log rotation\n   - Verify performance impact is minimal",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Authentication System",
        "description": "Create an authentication system that handles API key management and injection into requests, with support for global and per-call configurations.",
        "details": "1. Create an Authentication class in `src/core/authentication.ts`:\n```typescript\nimport { Logger } from '../logging/logger';\n\nexport interface AuthConfig {\n  apiKey?: string;\n  headerName?: string;\n}\n\nexport class Authentication {\n  private apiKey: string | null = null;\n  private headerName: string;\n  private logger: Logger;\n\n  constructor(config: AuthConfig = {}, logger: Logger) {\n    this.apiKey = config.apiKey || null;\n    this.headerName = config.headerName || 'chave-api-portal';\n    this.logger = logger;\n  }\n\n  setApiKey(apiKey: string): void {\n    this.apiKey = apiKey;\n    this.logger.info('API key updated');\n  }\n\n  getAuthHeaders(overrideApiKey?: string): Record<string, string> {\n    const key = overrideApiKey || this.apiKey;\n    \n    if (!key) {\n      this.logger.warn('No API key provided for authentication');\n      return {};\n    }\n    \n    return { [this.headerName]: key };\n  }\n\n  hasApiKey(): boolean {\n    return !!this.apiKey;\n  }\n\n  validateApiKey(): boolean {\n    // Basic validation - could be expanded\n    return this.hasApiKey() && this.apiKey!.length > 0;\n  }\n}\n```\n2. Add support for loading API key from environment variables:\n```typescript\n// In constructor\nthis.apiKey = config.apiKey || process.env.PORTAL_TRANSPARENCIA_API_KEY || null;\n```\n3. Implement a method to test API key validity with a simple endpoint call\n4. Add support for future OAuth implementation (placeholder)\n5. Create utility functions to securely store and retrieve API keys",
        "testStrategy": "1. Unit tests:\n   - Test header generation\n   - Test API key validation\n   - Test environment variable loading\n   - Test override functionality\n2. Integration tests:\n   - Test authentication against the actual API\n   - Verify error handling for invalid keys\n   - Test security of key storage",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Error Handling System",
        "description": "Create a comprehensive error handling system that categorizes API errors, provides meaningful messages, and handles rate limiting errors specifically.",
        "details": "1. Create custom error classes in `src/errors/api-errors.ts`:\n```typescript\nexport class ApiError extends Error {\n  statusCode: number;\n  endpoint: string;\n  requestPayload?: any;\n  responseBody?: any;\n\n  constructor(message: string, statusCode: number, endpoint: string, requestPayload?: any, responseBody?: any) {\n    super(message);\n    this.name = 'ApiError';\n    this.statusCode = statusCode;\n    this.endpoint = endpoint;\n    this.requestPayload = requestPayload;\n    this.responseBody = responseBody;\n  }\n\n  isClientError(): boolean {\n    return this.statusCode >= 400 && this.statusCode < 500;\n  }\n\n  isServerError(): boolean {\n    return this.statusCode >= 500;\n  }\n}\n\nexport class RateLimitError extends ApiError {\n  retryAfter?: number;\n  currentLimit: number;\n  \n  constructor(message: string, endpoint: string, currentLimit: number, retryAfter?: number) {\n    super(message, 429, endpoint);\n    this.name = 'RateLimitError';\n    this.currentLimit = currentLimit;\n    this.retryAfter = retryAfter;\n  }\n}\n\nexport class AuthenticationError extends ApiError {\n  constructor(message: string, endpoint: string) {\n    super(message, 401, endpoint);\n    this.name = 'AuthenticationError';\n  }\n}\n\nexport class NotFoundError extends ApiError {\n  constructor(message: string, endpoint: string) {\n    super(message, 404, endpoint);\n    this.name = 'NotFoundError';\n  }\n}\n```\n2. Create an ErrorHandler class in `src/errors/error-handler.ts`:\n```typescript\nimport { Logger } from '../logging/logger';\nimport { ApiError, RateLimitError, AuthenticationError, NotFoundError } from './api-errors';\n\nexport class ErrorHandler {\n  private logger: Logger;\n\n  constructor(logger: Logger) {\n    this.logger = logger;\n  }\n\n  handleApiError(error: any, endpoint: string, requestPayload?: any): Error {\n    if (error.response) {\n      const { status, data } = error.response;\n      \n      // Handle rate limiting errors\n      if (status === 429) {\n        const retryAfter = parseInt(error.response.headers['retry-after'] || '60', 10);\n        const message = 'Rate limit exceeded for Portal da Transparência API';\n        const rateLimitError = new RateLimitError(message, endpoint, 90, retryAfter);\n        \n        this.logger.warn(message, {\n          endpoint,\n          status,\n          retryAfter,\n          responseData: data\n        });\n        \n        return rateLimitError;\n      }\n      \n      // Handle authentication errors\n      if (status === 401) {\n        const message = 'Authentication failed for Portal da Transparência API';\n        this.logger.error(message, { endpoint, status });\n        return new AuthenticationError(message, endpoint);\n      }\n      \n      // Handle not found errors\n      if (status === 404) {\n        const message = 'Resource not found in Portal da Transparência API';\n        this.logger.error(message, { endpoint, status });\n        return new NotFoundError(message, endpoint);\n      }\n      \n      // Generic API error\n      const message = `API error: ${data?.message || 'Unknown error'}`;\n      this.logger.error(message, {\n        endpoint,\n        status,\n        requestPayload,\n        responseData: data\n      });\n      \n      return new ApiError(message, status, endpoint, requestPayload, data);\n    }\n    \n    // Network or other errors\n    const message = `Request failed: ${error.message}`;\n    this.logger.error(message, { endpoint, error: error.message });\n    return new Error(message);\n  }\n\n  isRateLimitError(error: any): error is RateLimitError {\n    return error instanceof RateLimitError;\n  }\n}\n```\n3. Implement rate limit detection from error messages\n4. Add retry logic for transient errors\n5. Create user-friendly error messages for common error scenarios",
        "testStrategy": "1. Unit tests:\n   - Test error classification\n   - Test rate limit detection\n   - Test error message formatting\n   - Test retry logic\n2. Integration tests:\n   - Test with actual API errors\n   - Verify rate limit detection works with real API responses\n   - Test error handling in full request flow",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Rate Limiting Monitor",
        "description": "Create a rate limiting monitor that tracks API usage, provides alerts when approaching limits, and helps manage request timing to avoid exceeding limits.",
        "details": "1. Create a RateLimiter class in `src/core/rate-limiter.ts`:\n```typescript\nimport { Logger } from '../logging/logger';\n\ninterface RateLimitConfig {\n  dayTimeLimit?: number;  // 6:00-23:59 limit\n  nightTimeLimit?: number; // 00:00-5:59 limit\n  alertThreshold?: number; // Percentage threshold for alerts\n}\n\nexport class RateLimiter {\n  private dayTimeLimit: number;\n  private nightTimeLimit: number;\n  private alertThreshold: number;\n  private requestCounts: Map<string, number> = new Map();\n  private logger: Logger;\n\n  constructor(config: RateLimitConfig = {}, logger: Logger) {\n    this.dayTimeLimit = config.dayTimeLimit || 90;\n    this.nightTimeLimit = config.nightTimeLimit || 300;\n    this.alertThreshold = config.alertThreshold || 0.8; // 80%\n    this.logger = logger;\n    \n    // Reset counters every minute\n    setInterval(() => this.resetCounters(), 60000);\n  }\n\n  private getCurrentLimit(): number {\n    const hour = new Date().getHours();\n    return (hour >= 6 && hour < 24) ? this.dayTimeLimit : this.nightTimeLimit;\n  }\n\n  private getMinuteKey(): string {\n    const now = new Date();\n    return `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}-${now.getHours()}-${now.getMinutes()}`;\n  }\n\n  private resetCounters(): void {\n    this.requestCounts.clear();\n    this.logger.debug('Rate limit counters reset');\n  }\n\n  trackRequest(): void {\n    const key = this.getMinuteKey();\n    const currentCount = this.requestCounts.get(key) || 0;\n    this.requestCounts.set(key, currentCount + 1);\n    \n    const currentLimit = this.getCurrentLimit();\n    const usagePercentage = (currentCount + 1) / currentLimit;\n    \n    if (usagePercentage >= this.alertThreshold) {\n      this.logger.warn('Approaching rate limit', {\n        currentCount: currentCount + 1,\n        limit: currentLimit,\n        usagePercentage: usagePercentage.toFixed(2),\n        timeWindow: this.getMinuteKey()\n      });\n    }\n  }\n\n  getCurrentUsage(): { count: number; limit: number; percentage: number } {\n    const key = this.getMinuteKey();\n    const currentCount = this.requestCounts.get(key) || 0;\n    const currentLimit = this.getCurrentLimit();\n    \n    return {\n      count: currentCount,\n      limit: currentLimit,\n      percentage: currentCount / currentLimit\n    };\n  }\n\n  shouldThrottle(): boolean {\n    const { count, limit } = this.getCurrentUsage();\n    return count >= limit;\n  }\n}\n```\n2. Add event emitter for rate limit alerts\n3. Implement adaptive throttling based on time of day\n4. Add support for custom alert callbacks\n5. Create utility to estimate remaining requests in current window",
        "testStrategy": "1. Unit tests:\n   - Test limit calculation based on time of day\n   - Test counter incrementation\n   - Test alert threshold detection\n   - Test counter reset functionality\n2. Integration tests:\n   - Test with simulated high-frequency requests\n   - Verify alerts are triggered at appropriate thresholds\n   - Test throttling behavior",
        "priority": "medium",
        "dependencies": [
          1,
          3,
          5
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement API Client Generator",
        "description": "Create a module that automatically generates TypeScript client classes for each endpoint in the Portal da Transparência API based on the Swagger specification.",
        "details": "1. Install required dependencies:\n   - `npm install openapi-typescript-codegen handlebars --save-dev`\n2. Create a ClientGenerator class in `src/core/client-generator.ts`:\n```typescript\nimport { OpenAPI } from 'openapi-types';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport Handlebars from 'handlebars';\nimport { Logger } from '../logging/logger';\n\nexport class ClientGenerator {\n  private spec: OpenAPI.Document;\n  private outputDir: string;\n  private logger: Logger;\n\n  constructor(spec: OpenAPI.Document, outputDir: string = './src/clients', logger: Logger) {\n    this.spec = spec;\n    this.outputDir = outputDir;\n    this.logger = logger;\n  }\n\n  async generateClients(): Promise<string[]> {\n    const generatedFiles: string[] = [];\n    \n    try {\n      // Ensure output directory exists\n      if (!fs.existsSync(this.outputDir)) {\n        fs.mkdirSync(this.outputDir, { recursive: true });\n      }\n      \n      // Load template\n      const templatePath = path.resolve(__dirname, '../templates/client.hbs');\n      const templateSource = fs.readFileSync(templatePath, 'utf8');\n      const template = Handlebars.compile(templateSource);\n      \n      // Group endpoints by tag\n      const endpointsByTag = this.groupEndpointsByTag();\n      \n      // Generate client for each tag\n      for (const [tag, endpoints] of Object.entries(endpointsByTag)) {\n        const clientName = this.formatClientName(tag);\n        const fileName = `${this.kebabCase(tag)}.ts`;\n        const filePath = path.join(this.outputDir, fileName);\n        \n        const clientCode = template({\n          clientName,\n          endpoints,\n          imports: this.generateImports(endpoints),\n          interfaces: this.generateInterfaces(endpoints)\n        });\n        \n        fs.writeFileSync(filePath, clientCode);\n        generatedFiles.push(filePath);\n        \n        this.logger.info(`Generated client for ${tag}`, { filePath });\n      }\n      \n      // Generate index file\n      this.generateIndexFile(Object.keys(endpointsByTag));\n      \n      return generatedFiles;\n    } catch (error) {\n      this.logger.error('Failed to generate clients', { error });\n      throw new Error(`Client generation failed: ${error.message}`);\n    }\n  }\n\n  private groupEndpointsByTag(): Record<string, any[]> {\n    const endpointsByTag: Record<string, any[]> = {};\n    \n    // Process paths and operations\n    for (const [path, pathItem] of Object.entries(this.spec.paths)) {\n      for (const [method, operation] of Object.entries(pathItem)) {\n        if (!operation) continue;\n        \n        const tag = operation.tags?.[0] || 'Default';\n        \n        if (!endpointsByTag[tag]) {\n          endpointsByTag[tag] = [];\n        }\n        \n        endpointsByTag[tag].push({\n          path,\n          method: method.toUpperCase(),\n          operationId: operation.operationId || `${method}${this.formatClientName(path)}`,\n          summary: operation.summary,\n          description: operation.description,\n          parameters: operation.parameters,\n          requestBody: operation.requestBody,\n          responses: operation.responses\n        });\n      }\n    }\n    \n    return endpointsByTag;\n  }\n\n  private formatClientName(str: string): string {\n    return str\n      .split(/[-_\\s/{}]/)\n      .map(part => part.charAt(0).toUpperCase() + part.slice(1))\n      .join('')\n      .replace(/[^a-zA-Z0-9]/g, '')\n      + 'Client';\n  }\n\n  private kebabCase(str: string): string {\n    return str\n      .replace(/([a-z])([A-Z])/g, '$1-$2')\n      .replace(/[\\s_]+/g, '-')\n      .toLowerCase();\n  }\n\n  private generateImports(endpoints: any[]): string {\n    // Generate necessary imports\n    return '';\n  }\n\n  private generateInterfaces(endpoints: any[]): string {\n    // Generate TypeScript interfaces for request/response\n    return '';\n  }\n\n  private generateIndexFile(tags: string[]): void {\n    const indexPath = path.join(this.outputDir, 'index.ts');\n    const exports = tags.map(tag => {\n      const fileName = this.kebabCase(tag);\n      const clientName = this.formatClientName(tag);\n      return `export { ${clientName} } from './${fileName}';`;\n    }).join('\\n');\n    \n    fs.writeFileSync(indexPath, exports);\n    this.logger.info('Generated index file', { path: indexPath });\n  }\n}\n```\n3. Create Handlebars templates for client generation\n4. Implement type generation for request/response objects\n5. Add support for path parameters, query parameters, and request bodies\n6. Generate proper TypeScript documentation",
        "testStrategy": "1. Unit tests:\n   - Test client name formatting\n   - Test endpoint grouping\n   - Test template rendering\n   - Test type generation\n2. Integration tests:\n   - Test with actual Swagger spec\n   - Verify generated clients can make API calls\n   - Test type safety of generated code",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement HTTP Client with Interceptors",
        "description": "Create a base HTTP client with interceptors for authentication, error handling, logging, and rate limiting.",
        "details": "1. Install required dependencies:\n   - `npm install axios axios-retry --save`\n2. Create a HttpClient class in `src/core/http-client.ts`:\n```typescript\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';\nimport axiosRetry from 'axios-retry';\nimport { Authentication } from './authentication';\nimport { ErrorHandler } from '../errors/error-handler';\nimport { Logger } from '../logging/logger';\nimport { RateLimiter } from './rate-limiter';\n\nexport interface HttpClientConfig {\n  baseURL?: string;\n  timeout?: number;\n  retries?: number;\n}\n\nexport class HttpClient {\n  private client: AxiosInstance;\n  private auth: Authentication;\n  private errorHandler: ErrorHandler;\n  private logger: Logger;\n  private rateLimiter: RateLimiter;\n\n  constructor(\n    auth: Authentication,\n    errorHandler: ErrorHandler,\n    logger: Logger,\n    rateLimiter: RateLimiter,\n    config: HttpClientConfig = {}\n  ) {\n    this.auth = auth;\n    this.errorHandler = errorHandler;\n    this.logger = logger;\n    this.rateLimiter = rateLimiter;\n    \n    this.client = axios.create({\n      baseURL: config.baseURL || 'https://api.portaldatransparencia.gov.br',\n      timeout: config.timeout || 30000,\n    });\n    \n    // Configure retries\n    axiosRetry(this.client, {\n      retries: config.retries || 3,\n      retryDelay: axiosRetry.exponentialDelay,\n      retryCondition: (error) => {\n        // Only retry on network errors and 5xx responses\n        return axiosRetry.isNetworkOrIdempotentRequestError(error) ||\n          (error.response?.status >= 500 && error.response?.status < 600);\n      }\n    });\n    \n    this.setupInterceptors();\n  }\n\n  private setupInterceptors(): void {\n    // Request interceptor\n    this.client.interceptors.request.use(\n      (config) => {\n        const startTime = Date.now();\n        config.metadata = { startTime };\n        \n        // Add authentication headers\n        const authHeaders = this.auth.getAuthHeaders();\n        config.headers = { ...config.headers, ...authHeaders };\n        \n        // Track request for rate limiting\n        this.rateLimiter.trackRequest();\n        \n        return config;\n      },\n      (error) => {\n        this.logger.error('Request error', { error: error.message });\n        return Promise.reject(error);\n      }\n    );\n    \n    // Response interceptor\n    this.client.interceptors.response.use(\n      (response) => {\n        const config = response.config as AxiosRequestConfig & { metadata?: any };\n        const duration = Date.now() - (config.metadata?.startTime || 0);\n        \n        this.logger.logApiCall({\n          endpoint: `${config.method?.toUpperCase()} ${config.url}`,\n          method: config.method?.toUpperCase() || 'UNKNOWN',\n          requestPayload: config.data,\n          responseStatus: response.status,\n          responseTime: duration\n        });\n        \n        return response;\n      },\n      (error) => {\n        const config = error.config as AxiosRequestConfig & { metadata?: any };\n        const duration = Date.now() - (config.metadata?.startTime || 0);\n        \n        this.logger.logApiCall({\n          endpoint: `${config.method?.toUpperCase()} ${config.url}`,\n          method: config.method?.toUpperCase() || 'UNKNOWN',\n          requestPayload: config.data,\n          responseStatus: error.response?.status,\n          responseTime: duration,\n          error\n        });\n        \n        // Transform error\n        const transformedError = this.errorHandler.handleApiError(\n          error,\n          `${config.method?.toUpperCase()} ${config.url}`,\n          config.data\n        );\n        \n        return Promise.reject(transformedError);\n      }\n    );\n  }\n\n  async request<T>(config: AxiosRequestConfig): Promise<T> {\n    try {\n      const response = await this.client.request<T>(config);\n      return response.data;\n    } catch (error) {\n      throw error; // Already transformed by interceptor\n    }\n  }\n\n  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    return this.request<T>({ ...config, method: 'GET', url });\n  }\n\n  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    return this.request<T>({ ...config, method: 'POST', url, data });\n  }\n\n  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    return this.request<T>({ ...config, method: 'PUT', url, data });\n  }\n\n  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    return this.request<T>({ ...config, method: 'DELETE', url });\n  }\n}\n```\n3. Implement request/response timing for performance monitoring\n4. Add circuit breaker pattern for failing endpoints\n5. Implement request queuing for rate limiting\n6. Add support for request cancellation",
        "testStrategy": "1. Unit tests:\n   - Test interceptor functionality\n   - Test authentication header injection\n   - Test error transformation\n   - Test retry logic\n2. Integration tests:\n   - Test with mock API endpoints\n   - Verify rate limiting behavior\n   - Test error handling with various response codes\n   - Measure performance impact of interceptors",
        "priority": "high",
        "dependencies": [
          1,
          3,
          4,
          5,
          6
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Multi-step Call Planner Core",
        "description": "Create the core MCP functionality that allows chaining multiple API calls in a sequence with dependency management.",
        "details": "1. Create interfaces for the MCP in `src/types/mcp.ts`:\n```typescript\nexport interface MCPStep {\n  id: string;\n  name: string;\n  execute: (context: MCPContext) => Promise<any>;\n  dependsOn?: string[];\n  onSuccess?: (result: any, context: MCPContext) => void;\n  onError?: (error: Error, context: MCPContext) => void;\n  retryConfig?: {\n    maxRetries: number;\n    retryDelay: number;\n  };\n}\n\nexport interface MCPContext {\n  results: Record<string, any>;\n  errors: Record<string, Error>;\n  metadata: Record<string, any>;\n}\n\nexport interface MCPConfig {\n  continueOnError?: boolean;\n  timeout?: number;\n  concurrency?: number;\n}\n```\n2. Create the MCP class in `src/core/mcp.ts`:\n```typescript\nimport { MCPStep, MCPContext, MCPConfig } from '../types/mcp';\nimport { Logger } from '../logging/logger';\n\nexport class MCP {\n  private steps: MCPStep[] = [];\n  private context: MCPContext;\n  private config: MCPConfig;\n  private logger: Logger;\n\n  constructor(config: MCPConfig = {}, logger: Logger) {\n    this.config = {\n      continueOnError: config.continueOnError ?? false,\n      timeout: config.timeout ?? 300000, // 5 minutes\n      concurrency: config.concurrency ?? 1, // Sequential by default\n    };\n    \n    this.context = {\n      results: {},\n      errors: {},\n      metadata: {},\n    };\n    \n    this.logger = logger;\n  }\n\n  addStep(step: MCPStep): MCP {\n    this.steps.push(step);\n    return this;\n  }\n\n  addSteps(steps: MCPStep[]): MCP {\n    this.steps.push(...steps);\n    return this;\n  }\n\n  setContext(context: Partial<MCPContext>): MCP {\n    this.context = { ...this.context, ...context };\n    return this;\n  }\n\n  private validateSteps(): void {\n    // Check for duplicate IDs\n    const ids = this.steps.map(step => step.id);\n    const uniqueIds = new Set(ids);\n    \n    if (ids.length !== uniqueIds.size) {\n      throw new Error('Duplicate step IDs found');\n    }\n    \n    // Check for circular dependencies\n    for (const step of this.steps) {\n      if (!step.dependsOn) continue;\n      \n      const visited = new Set<string>();\n      const checkCircular = (stepId: string, path: string[] = []): boolean => {\n        if (path.includes(stepId)) {\n          this.logger.error('Circular dependency detected', { path: [...path, stepId] });\n          return true;\n        }\n        \n        if (visited.has(stepId)) return false;\n        visited.add(stepId);\n        \n        const step = this.steps.find(s => s.id === stepId);\n        if (!step || !step.dependsOn) return false;\n        \n        for (const depId of step.dependsOn) {\n          if (checkCircular(depId, [...path, stepId])) {\n            return true;\n          }\n        }\n        \n        return false;\n      };\n      \n      for (const depId of step.dependsOn) {\n        if (checkCircular(depId)) {\n          throw new Error(`Circular dependency detected: ${depId}`);\n        }\n      }\n    }\n  }\n\n  private canExecuteStep(step: MCPStep): boolean {\n    if (!step.dependsOn || step.dependsOn.length === 0) {\n      return true;\n    }\n    \n    // Check if all dependencies have completed successfully\n    return step.dependsOn.every(depId => {\n      const hasResult = depId in this.context.results;\n      const hasError = depId in this.context.errors;\n      \n      return hasResult && (!hasError || this.config.continueOnError);\n    });\n  }\n\n  async execute(): Promise<MCPContext> {\n    this.validateSteps();\n    \n    // Sort steps based on dependencies\n    const executionOrder = this.topologicalSort();\n    \n    this.logger.info('Starting MCP execution', {\n      stepCount: this.steps.length,\n      executionOrder: executionOrder.map(step => step.id)\n    });\n    \n    const startTime = Date.now();\n    \n    try {\n      if (this.config.concurrency === 1) {\n        // Sequential execution\n        for (const step of executionOrder) {\n          await this.executeStep(step);\n        }\n      } else {\n        // Parallel execution with dependency respect\n        let remainingSteps = [...executionOrder];\n        \n        while (remainingSteps.length > 0) {\n          const executableSteps = remainingSteps.filter(step => this.canExecuteStep(step));\n          \n          if (executableSteps.length === 0) {\n            // Deadlock or all remaining steps have failed dependencies\n            break;\n          }\n          \n          // Execute steps in parallel up to concurrency limit\n          const batch = executableSteps.slice(0, this.config.concurrency);\n          await Promise.all(batch.map(step => this.executeStep(step)));\n          \n          // Remove executed steps\n          remainingSteps = remainingSteps.filter(step => \n            !batch.some(s => s.id === step.id)\n          );\n        }\n      }\n    } catch (error) {\n      this.logger.error('MCP execution failed', { error });\n      throw error;\n    } finally {\n      const duration = Date.now() - startTime;\n      this.context.metadata.executionTime = duration;\n      \n      this.logger.info('MCP execution completed', {\n        duration,\n        successCount: Object.keys(this.context.results).length,\n        errorCount: Object.keys(this.context.errors).length\n      });\n    }\n    \n    return this.context;\n  }\n\n  private async executeStep(step: MCPStep): Promise<void> {\n    if (!this.canExecuteStep(step)) {\n      this.logger.warn(`Skipping step ${step.id} due to failed dependencies`);\n      return;\n    }\n    \n    this.logger.info(`Executing step: ${step.id} - ${step.name}`);\n    const startTime = Date.now();\n    \n    try {\n      const result = await step.execute(this.context);\n      this.context.results[step.id] = result;\n      \n      if (step.onSuccess) {\n        step.onSuccess(result, this.context);\n      }\n      \n      const duration = Date.now() - startTime;\n      this.logger.info(`Step ${step.id} completed successfully`, { duration });\n    } catch (error) {\n      this.context.errors[step.id] = error;\n      \n      if (step.onError) {\n        step.onError(error, this.context);\n      }\n      \n      const duration = Date.now() - startTime;\n      this.logger.error(`Step ${step.id} failed`, { error, duration });\n      \n      if (!this.config.continueOnError) {\n        throw error;\n      }\n    }\n  }\n\n  private topologicalSort(): MCPStep[] {\n    const result: MCPStep[] = [];\n    const visited = new Set<string>();\n    const temp = new Set<string>();\n    \n    const visit = (stepId: string): void => {\n      if (temp.has(stepId)) {\n        throw new Error(`Circular dependency detected: ${stepId}`);\n      }\n      \n      if (visited.has(stepId)) return;\n      \n      const step = this.steps.find(s => s.id === stepId);\n      if (!step) return;\n      \n      temp.add(stepId);\n      \n      if (step.dependsOn) {\n        for (const depId of step.dependsOn) {\n          visit(depId);\n        }\n      }\n      \n      temp.delete(stepId);\n      visited.add(stepId);\n      result.push(step);\n    };\n    \n    for (const step of this.steps) {\n      if (!visited.has(step.id)) {\n        visit(step.id);\n      }\n    }\n    \n    return result;\n  }\n\n  reset(): MCP {\n    this.context = {\n      results: {},\n      errors: {},\n      metadata: {},\n    };\n    return this;\n  }\n}\n```\n3. Implement timeout handling for long-running steps\n4. Add support for conditional step execution\n5. Implement step result transformation\n6. Add support for step retries with backoff",
        "testStrategy": "1. Unit tests:\n   - Test dependency validation\n   - Test topological sorting\n   - Test step execution order\n   - Test error handling\n   - Test parallel execution\n2. Integration tests:\n   - Test with mock steps\n   - Verify context passing between steps\n   - Test timeout handling\n   - Test with actual API clients",
        "priority": "high",
        "dependencies": [
          1,
          3,
          5,
          8
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement API Client Integration with MCP",
        "description": "Integrate the generated API clients with the MCP core to enable seamless chaining of API calls.",
        "details": "1. Create a ClientFactory class in `src/core/client-factory.ts`:\n```typescript\nimport { HttpClient } from './http-client';\nimport { Logger } from '../logging/logger';\nimport { Authentication } from './authentication';\nimport { ErrorHandler } from '../errors/error-handler';\nimport { RateLimiter } from './rate-limiter';\nimport * as clients from '../clients';\n\nexport class ClientFactory {\n  private httpClient: HttpClient;\n  private logger: Logger;\n\n  constructor(httpClient: HttpClient, logger: Logger) {\n    this.httpClient = httpClient;\n    this.logger = logger;\n  }\n\n  createClient<T extends keyof typeof clients>(clientName: T): InstanceType<typeof clients[T]> {\n    const ClientClass = clients[clientName];\n    \n    if (!ClientClass) {\n      throw new Error(`Client not found: ${clientName}`);\n    }\n    \n    return new ClientClass(this.httpClient) as InstanceType<typeof clients[T]>;\n  }\n\n  createAllClients(): Record<keyof typeof clients, any> {\n    const allClients: Record<string, any> = {};\n    \n    for (const clientName of Object.keys(clients)) {\n      allClients[clientName] = this.createClient(clientName as keyof typeof clients);\n    }\n    \n    return allClients as Record<keyof typeof clients, any>;\n  }\n}\n```\n2. Create a MCPBuilder class for fluent API creation in `src/core/mcp-builder.ts`:\n```typescript\nimport { MCP } from './mcp';\nimport { MCPStep, MCPConfig } from '../types/mcp';\nimport { ClientFactory } from './client-factory';\nimport { Logger } from '../logging/logger';\n\nexport class MCPBuilder {\n  private mcp: MCP;\n  private clientFactory: ClientFactory;\n  private logger: Logger;\n\n  constructor(config: MCPConfig = {}, clientFactory: ClientFactory, logger: Logger) {\n    this.logger = logger;\n    this.mcp = new MCP(config, logger);\n    this.clientFactory = clientFactory;\n  }\n\n  addStep(step: MCPStep): MCPBuilder {\n    this.mcp.addStep(step);\n    return this;\n  }\n\n  addApiCall<T>(\n    id: string,\n    clientName: string,\n    methodName: string,\n    params: any = {},\n    options: {\n      dependsOn?: string[];\n      transform?: (result: any, context: any) => T;\n      retries?: number;\n    } = {}\n  ): MCPBuilder {\n    const step: MCPStep = {\n      id,\n      name: `${clientName}.${methodName}`,\n      dependsOn: options.dependsOn || [],\n      execute: async (context) => {\n        const client = this.clientFactory.createClient(clientName);\n        \n        if (!client[methodName]) {\n          throw new Error(`Method ${methodName} not found on client ${clientName}`);\n        }\n        \n        // Resolve parameter values from context if needed\n        const resolvedParams = this.resolveParamsFromContext(params, context);\n        \n        const result = await client[methodName](resolvedParams);\n        return options.transform ? options.transform(result, context) : result;\n      },\n      retryConfig: options.retries ? {\n        maxRetries: options.retries,\n        retryDelay: 1000,\n      } : undefined,\n    };\n    \n    this.mcp.addStep(step);\n    return this;\n  }\n\n  private resolveParamsFromContext(params: any, context: any): any {\n    if (!params) return {};\n    \n    const resolved = { ...params };\n    \n    // Look for special syntax like \"$result.stepId.property\"\n    for (const [key, value] of Object.entries(resolved)) {\n      if (typeof value === 'string' && value.startsWith('$result.')) {\n        const path = value.substring(8).split('.');\n        const stepId = path[0];\n        \n        if (context.results[stepId]) {\n          let currentValue = context.results[stepId];\n          \n          for (let i = 1; i < path.length; i++) {\n            currentValue = currentValue[path[i]];\n            if (currentValue === undefined) break;\n          }\n          \n          resolved[key] = currentValue;\n        }\n      } else if (typeof value === 'object') {\n        resolved[key] = this.resolveParamsFromContext(value, context);\n      }\n    }\n    \n    return resolved;\n  }\n\n  build(): MCP {\n    return this.mcp;\n  }\n\n  async execute(): Promise<any> {\n    return this.mcp.execute();\n  }\n}\n```\n3. Create utility functions for common API call patterns\n4. Implement parameter resolution from previous step results\n5. Add support for conditional API calls\n6. Implement result transformation and filtering",
        "testStrategy": "1. Unit tests:\n   - Test parameter resolution\n   - Test client creation\n   - Test step building\n   - Test transformation functions\n2. Integration tests:\n   - Test with mock API responses\n   - Verify data flows correctly between steps\n   - Test error handling in chained calls\n   - Test with actual API endpoints",
        "priority": "high",
        "dependencies": [
          7,
          8,
          9
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Caching System",
        "description": "Create a caching system to improve performance and reduce unnecessary API calls.",
        "details": "1. Install required dependencies:\n   - `npm install node-cache --save`\n2. Create a CacheManager class in `src/core/cache-manager.ts`:\n```typescript\nimport NodeCache from 'node-cache';\nimport { Logger } from '../logging/logger';\n\nexport interface CacheConfig {\n  stdTTL?: number; // Default TTL in seconds\n  checkperiod?: number; // How often to check for expired keys\n  maxKeys?: number; // Maximum number of keys in cache\n  useClones?: boolean; // Whether to clone objects on get/set\n}\n\nexport class CacheManager {\n  private cache: NodeCache;\n  private logger: Logger;\n  private enabled: boolean = true;\n\n  constructor(config: CacheConfig = {}, logger: Logger) {\n    this.cache = new NodeCache({\n      stdTTL: config.stdTTL || 300, // 5 minutes default\n      checkperiod: config.checkperiod || 60, // Check every minute\n      maxKeys: config.maxKeys || 1000,\n      useClones: config.useClones !== undefined ? config.useClones : true,\n    });\n    \n    this.logger = logger;\n    \n    // Setup event listeners\n    this.cache.on('expired', (key, value) => {\n      this.logger.debug('Cache key expired', { key });\n    });\n    \n    this.cache.on('flush', () => {\n      this.logger.debug('Cache flushed');\n    });\n  }\n\n  set<T>(key: string, value: T, ttl?: number): boolean {\n    if (!this.enabled) return false;\n    \n    try {\n      const result = this.cache.set(key, value, ttl);\n      this.logger.debug('Cache set', { key, ttl });\n      return result;\n    } catch (error) {\n      this.logger.error('Cache set error', { key, error });\n      return false;\n    }\n  }\n\n  get<T>(key: string): T | undefined {\n    if (!this.enabled) return undefined;\n    \n    try {\n      const value = this.cache.get<T>(key);\n      this.logger.debug('Cache get', { key, hit: value !== undefined });\n      return value;\n    } catch (error) {\n      this.logger.error('Cache get error', { key, error });\n      return undefined;\n    }\n  }\n\n  delete(key: string): number {\n    try {\n      const result = this.cache.del(key);\n      this.logger.debug('Cache delete', { key });\n      return result;\n    } catch (error) {\n      this.logger.error('Cache delete error', { key, error });\n      return 0;\n    }\n  }\n\n  flush(): void {\n    try {\n      this.cache.flushAll();\n      this.logger.debug('Cache flushed');\n    } catch (error) {\n      this.logger.error('Cache flush error', { error });\n    }\n  }\n\n  enable(): void {\n    this.enabled = true;\n    this.logger.info('Cache enabled');\n  }\n\n  disable(): void {\n    this.enabled = false;\n    this.logger.info('Cache disabled');\n  }\n\n  isEnabled(): boolean {\n    return this.enabled;\n  }\n\n  getStats(): NodeCache.Stats {\n    return this.cache.getStats();\n  }\n}\n```\n3. Integrate cache with HttpClient:\n```typescript\n// In HttpClient class\nprivate cacheManager: CacheManager;\n\nconstructor(\n  auth: Authentication,\n  errorHandler: ErrorHandler,\n  logger: Logger,\n  rateLimiter: RateLimiter,\n  cacheManager: CacheManager,\n  config: HttpClientConfig = {}\n) {\n  // ... existing code\n  this.cacheManager = cacheManager;\n}\n\nasync get<T>(url: string, config?: AxiosRequestConfig & { skipCache?: boolean }): Promise<T> {\n  if (!config?.skipCache) {\n    const cacheKey = `GET:${url}:${JSON.stringify(config?.params || {})}`;\n    const cachedData = this.cacheManager.get<T>(cacheKey);\n    \n    if (cachedData) {\n      this.logger.debug('Using cached response', { url });\n      return cachedData;\n    }\n    \n    const response = await this.request<T>({ ...config, method: 'GET', url });\n    this.cacheManager.set(cacheKey, response);\n    return response;\n  }\n  \n  return this.request<T>({ ...config, method: 'GET', url });\n}\n```\n4. Add cache invalidation strategies\n5. Implement cache key generation based on request parameters\n6. Add cache statistics and monitoring",
        "testStrategy": "1. Unit tests:\n   - Test cache set/get operations\n   - Test TTL functionality\n   - Test cache key generation\n   - Test cache invalidation\n2. Integration tests:\n   - Test caching with HTTP client\n   - Verify performance improvement\n   - Test cache hit/miss rates\n   - Test memory usage",
        "priority": "medium",
        "dependencies": [
          1,
          3,
          8
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Main MCP Class and Public API",
        "description": "Create the main MCP class that serves as the public API for the library, integrating all components.",
        "details": "1. Create the main MCP class in `src/index.ts`:\n```typescript\nimport { Authentication, AuthConfig } from './core/authentication';\nimport { SwaggerLoader } from './core/swagger-loader';\nimport { Logger, LoggerOptions } from './logging/logger';\nimport { ErrorHandler } from './errors/error-handler';\nimport { RateLimiter } from './core/rate-limiter';\nimport { HttpClient, HttpClientConfig } from './core/http-client';\nimport { ClientFactory } from './core/client-factory';\nimport { MCPBuilder } from './core/mcp-builder';\nimport { CacheManager, CacheConfig } from './core/cache-manager';\nimport { MCPConfig } from './types/mcp';\n\nexport interface MCPOptions {\n  auth?: AuthConfig;\n  logger?: LoggerOptions;\n  http?: HttpClientConfig;\n  cache?: CacheConfig;\n  rateLimiter?: {\n    dayTimeLimit?: number;\n    nightTimeLimit?: number;\n    alertThreshold?: number;\n  };\n  swaggerUrl?: string;\n}\n\nexport class PortalTransparenciaMCP {\n  private logger: Logger;\n  private auth: Authentication;\n  private errorHandler: ErrorHandler;\n  private rateLimiter: RateLimiter;\n  private cacheManager: CacheManager;\n  private httpClient: HttpClient;\n  private clientFactory: ClientFactory;\n  private swaggerLoader: SwaggerLoader;\n\n  constructor(options: MCPOptions = {}) {\n    // Initialize components\n    this.logger = new Logger(options.logger);\n    this.auth = new Authentication(options.auth, this.logger);\n    this.errorHandler = new ErrorHandler(this.logger);\n    this.rateLimiter = new RateLimiter(options.rateLimiter, this.logger);\n    this.cacheManager = new CacheManager(options.cache, this.logger);\n    this.httpClient = new HttpClient(\n      this.auth,\n      this.errorHandler,\n      this.logger,\n      this.rateLimiter,\n      this.cacheManager,\n      options.http\n    );\n    this.clientFactory = new ClientFactory(this.httpClient, this.logger);\n    this.swaggerLoader = new SwaggerLoader(options.swaggerUrl, this.logger);\n    \n    this.logger.info('Portal da Transparência MCP initialized');\n  }\n\n  setApiKey(apiKey: string): void {\n    this.auth.setApiKey(apiKey);\n  }\n\n  createFlow(config: MCPConfig = {}): MCPBuilder {\n    return new MCPBuilder(config, this.clientFactory, this.logger);\n  }\n\n  getClient<T extends string>(clientName: T): any {\n    return this.clientFactory.createClient(clientName);\n  }\n\n  getAllClients(): Record<string, any> {\n    return this.clientFactory.createAllClients();\n  }\n\n  async loadSwaggerSpec(): Promise<void> {\n    await this.swaggerLoader.loadSpec();\n  }\n\n  enableCache(): void {\n    this.cacheManager.enable();\n  }\n\n  disableCache(): void {\n    this.cacheManager.disable();\n  }\n\n  clearCache(): void {\n    this.cacheManager.flush();\n  }\n\n  getRateLimitStatus(): { count: number; limit: number; percentage: number } {\n    return this.rateLimiter.getCurrentUsage();\n  }\n}\n\n// Export types\nexport * from './types/mcp';\nexport * from './errors/api-errors';\n\n// Default export\nexport default PortalTransparenciaMCP;\n```\n2. Create a simple factory function for easier instantiation:\n```typescript\nexport function createMCP(options: MCPOptions = {}): PortalTransparenciaMCP {\n  return new PortalTransparenciaMCP(options);\n}\n```\n3. Add examples in the README for common use cases\n4. Implement convenience methods for common operations\n5. Add proper TypeScript exports for all public types\n6. Ensure backward compatibility for future versions",
        "testStrategy": "1. Unit tests:\n   - Test initialization with different options\n   - Test API key setting\n   - Test flow creation\n   - Test client retrieval\n2. Integration tests:\n   - Test full workflow with multiple components\n   - Verify all components are properly initialized\n   - Test with actual API endpoints\n   - Test error handling at the top level",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Unit Tests",
        "description": "Create focused unit tests for the core essential components of the MCP library, with emphasis on the MCP server implementation.",
        "status": "pending",
        "dependencies": [
          1,
          2,
          4,
          7,
          19
        ],
        "priority": "high",
        "details": "1. Install testing dependencies:\n   - `npm install jest ts-jest @types/jest jest-mock-extended --save-dev`\n2. Configure Jest in `jest.config.js`:\n```javascript\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  collectCoverage: true,\n  collectCoverageFrom: [\n    'src/**/*.ts',\n    '!src/**/*.d.ts',\n  ],\n  coverageThreshold: {\n    global: {\n      branches: 60,\n      functions: 60,\n      lines: 60,\n      statements: 60,\n    },\n  },\n  testMatch: ['**/tests/unit/**/*.test.ts'],\n};\n```\n3. Create test files for core essential components:\n   - `tests/unit/core/mcp-server.test.ts` (MCP server implementation)\n   - `tests/unit/core/tool-registry.test.ts` (Tool registration and management)\n   - `tests/unit/core/request-handler.test.ts` (Request/response handling)\n   - `tests/unit/core/authentication.test.ts` (Authentication mechanisms)\n4. Create basic test utilities and mocks in `tests/utils`\n5. Focus on MCP server functionality and tool management testing",
        "testStrategy": "1. Use Jest for basic unit testing\n2. Mock MCP protocol messages and responses\n3. Test tool registration and execution workflows\n4. Test MCP server request/response handling\n5. Mock authentication and authorization flows\n6. Focus on MCP server implementation, not complex edge cases\n7. Maintain reasonable test coverage without strict thresholds",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Integration Tests",
        "description": "Create comprehensive integration tests that verify all MCP tools work correctly with the actual Portal da Transparência API, testing connectivity and response structure for all endpoint categories through the MCP server interface.",
        "status": "pending",
        "dependencies": [
          19,
          13
        ],
        "priority": "medium",
        "details": "1. Create integration test configuration in `tests/integration/config.ts`:\n```typescript\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nexport const config = {\n  skipLiveTests: process.env.SKIP_LIVE_TESTS === 'true',\n  testTimeout: 30000,\n  mcpServerPort: process.env.MCP_SERVER_PORT || 3000,\n};\n```\n2. Create comprehensive test files for ALL API categories via MCP tools:\n   - `tests/integration/servidores.test.ts`\n   - `tests/integration/viagens.test.ts`\n   - `tests/integration/contratos.test.ts`\n   - `tests/integration/beneficios.test.ts`\n   - `tests/integration/orcamento.test.ts`\n   - `tests/integration/despesas.test.ts`\n   - `tests/integration/receitas.test.ts`\n   - `tests/integration/convenios.test.ts`\n   - `tests/integration/cartoes.test.ts`\n   - `tests/integration/auxilio-emergencial.test.ts`\n   - `tests/integration/seguro-defeso.test.ts`\n   - `tests/integration/bolsa-familia.test.ts`\n   - `tests/integration/bpc.test.ts`\n   - `tests/integration/peti.test.ts`\n3. Test ALL MCP tools functionality through the MCP server:\n   - Verify each MCP tool can make real API calls via server\n   - Test parameter validation and transformation through MCP interface\n   - Verify response structure and data consistency from MCP tools\n4. Create comprehensive MCP connectivity tests:\n   - Test MCP server startup and tool registration\n   - Verify MCP tool discovery and availability\n   - Test MCP communication protocol with actual API calls\n5. Implement end-to-end MCP integration tests:\n   - Test complete MCP client-server communication flow\n   - Verify tool execution through MCP protocol\n   - Test error handling and response formatting via MCP\n6. Create performance and reliability tests via MCP:\n   - Test rate limiting behavior through MCP tools\n   - Verify caching functionality with MCP server\n   - Test timeout handling and retry mechanisms in MCP context",
        "testStrategy": "1. Skip tests conditionally based on environment variables\n2. Focus on MCP tool functionality and API connectivity\n3. Test all endpoint categories through MCP server interface\n4. Verify complete MCP communication flow with real API calls\n5. Test MCP tool registration and discovery mechanisms\n6. Validate response schemas and data consistency via MCP\n7. Test error scenarios with actual API responses through MCP\n8. Measure performance with MCP server caching enabled/disabled",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Generate API Documentation",
        "description": "Generate comprehensive documentation for the MCP library focused on UI integration and user setup guides.",
        "status": "pending",
        "dependencies": [
          19
        ],
        "priority": "medium",
        "details": "1. Install documentation dependencies:\n   - `npm install typedoc --save-dev`\n2. Configure TypeDoc in `typedoc.json`:\n```json\n{\n  \"entryPoints\": [\"src/index.ts\"],\n  \"out\": \"docs\",\n  \"name\": \"Portal da Transparência MCP\",\n  \"readme\": \"README.md\",\n  \"includeVersion\": true,\n  \"excludePrivate\": true,\n  \"excludeExternals\": true,\n  \"theme\": \"default\"\n}\n```\n3. Create comprehensive user-focused documentation structure:\n   - Installation Guide (npx setup)\n   - Configuration Guides:\n     * Claude Desktop setup\n     * Cursor IDE setup\n     * Other UIs/editors setup\n   - Complete MCP Tools Reference\n   - Prompt Examples for Claude\n   - Step-by-step Setup Guides\n   - Troubleshooting Section\n4. Add JSDoc comments to all public classes and methods\n5. Create a documentation generation script in package.json:\n```json\n\"scripts\": {\n  \"docs\": \"typedoc\"\n}\n```\n6. Generate endpoint documentation from Swagger spec\n7. Create diagrams for setup flows and tool interactions\n8. Focus on documenting how to use the MCP server implementation from task 19",
        "testStrategy": "1. Verify documentation builds without errors\n2. Check that all public APIs are documented\n3. Validate links between documentation pages\n4. Test all setup instructions on different platforms\n5. Verify prompt examples work correctly with Claude\n6. Ensure troubleshooting guides address common issues\n7. Test documentation site in different browsers\n8. Validate that MCP server usage documentation is accurate and complete",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Installation Guide",
            "description": "Document how to install the MCP server using npx",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Claude Desktop Configuration Guide",
            "description": "Step-by-step guide for configuring MCP in Claude Desktop with screenshots",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Cursor IDE Configuration Guide",
            "description": "Detailed setup instructions for Cursor IDE integration",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Other UIs/Editors Configuration Guide",
            "description": "Generic configuration guide for other MCP-compatible UIs and editors",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Document All Available MCP Tools",
            "description": "Create comprehensive reference of all MCP tools with parameters and examples",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create Claude Prompt Examples",
            "description": "Provide example prompts showing how Claude can use each MCP tool effectively",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create Troubleshooting Guide",
            "description": "Document common issues and solutions for MCP setup and usage",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Create Setup Flow Diagrams",
            "description": "Visual diagrams showing the setup process for different UIs",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Document MCP Server Usage",
            "description": "Create detailed documentation on how to use the MCP server implementation, including API endpoints, configuration options, and integration patterns",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 16,
        "title": "Create Usage Examples",
        "description": "Create comprehensive examples demonstrating how to use the MCP for various common scenarios.",
        "details": "1. Create examples directory structure:\n```\nexamples/\n  ├── basic/\n  │   ├── simple-call.ts\n  │   ├── authentication.ts\n  │   └── error-handling.ts\n  ├── flows/\n  │   ├── sequential-calls.ts\n  │   ├── parallel-calls.ts\n  │   └── conditional-flows.ts\n  ├── endpoints/\n  │   ├── viagens.ts\n  │   ├── servidores.ts\n  │   ├── beneficios.ts\n  │   └── ...\n  └── advanced/\n      ├── rate-limiting.ts\n      ├── caching.ts\n      └── custom-clients.ts\n```\n2. Implement basic examples:\n```typescript\n// examples/basic/simple-call.ts\nimport PortalTransparenciaMCP from '../../src';\n\nasync function main() {\n  // Create MCP instance\n  const mcp = new PortalTransparenciaMCP({\n    auth: {\n      apiKey: process.env.PORTAL_TRANSPARENCIA_API_KEY,\n    },\n  });\n\n  // Get a specific client\n  const servidoresClient = mcp.getClient('ServidoresClient');\n\n  // Make a simple API call\n  try {\n    const result = await servidoresClient.getServidoresPorOrgao({\n      orgaoSuperior: '26000',\n      pagina: 1,\n    });\n\n    console.log(`Found ${result.totalElements} servers`);\n    console.log(result.content.slice(0, 5));\n  } catch (error) {\n    console.error('API call failed:', error.message);\n  }\n}\n\nmain();\n```\n3. Implement flow examples:\n```typescript\n// examples/flows/sequential-calls.ts\nimport PortalTransparenciaMCP from '../../src';\n\nasync function main() {\n  const mcp = new PortalTransparenciaMCP({\n    auth: {\n      apiKey: process.env.PORTAL_TRANSPARENCIA_API_KEY,\n    },\n  });\n\n  // Create a flow with sequential calls\n  const flow = mcp.createFlow()\n    .addApiCall(\n      'getOrgaos',\n      'OrgaosClient',\n      'getOrgaosSuperiores'\n    )\n    .addApiCall(\n      'getServidores',\n      'ServidoresClient',\n      'getServidoresPorOrgao',\n      {\n        orgaoSuperior: '$result.getOrgaos[0].codigo',\n        pagina: 1,\n      },\n      { dependsOn: ['getOrgaos'] }\n    )\n    .addApiCall(\n      'getDetalhes',\n      'ServidoresClient',\n      'getServidorDetalhes',\n      {\n        id: '$result.getServidores.content[0].id',\n      },\n      { dependsOn: ['getServidores'] }\n    );\n\n  // Execute the flow\n  try {\n    const result = await flow.execute();\n    console.log('Flow executed successfully');\n    console.log('Servidor details:', result.results.getDetalhes);\n  } catch (error) {\n    console.error('Flow execution failed:', error.message);\n  }\n}\n\nmain();\n```\n4. Create examples for each major endpoint category\n5. Add advanced examples for caching, rate limiting, and error handling\n6. Create a README for each example explaining its purpose",
        "testStrategy": "1. Verify all examples run without errors\n2. Test examples with actual API key\n3. Ensure examples cover all major features\n4. Check that examples are up-to-date with the latest API\n5. Validate output matches expected format",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "cancelled",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Create NPM Package Configuration",
        "description": "Configure the project for publishing as an NPM package that works as an MCP server via npx, with proper versioning, metadata, and distribution files.",
        "status": "done",
        "dependencies": [
          19,
          13,
          14,
          15
        ],
        "priority": "medium",
        "details": "1. Update package.json with MCP server configuration for npx usage:\n```json\n{\n  \"name\": \"mcp-portal-transparencia\",\n  \"version\": \"0.1.0\",\n  \"description\": \"MCP Server for Portal da Transparência API - Multi-step Call Planner\",\n  \"main\": \"dist/index.js\",\n  \"bin\": {\n    \"mcp-portal-transparencia\": \"dist/index.js\"\n  },\n  \"types\": \"dist/index.d.ts\",\n  \"files\": [\n    \"dist\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"test\": \"jest\",\n    \"test:unit\": \"jest --testMatch='**/tests/unit/**/*.test.ts'\",\n    \"test:integration\": \"jest --testMatch='**/tests/integration/**/*.test.ts'\",\n    \"lint\": \"eslint 'src/**/*.ts'\",\n    \"docs\": \"typedoc\",\n    \"prepublishOnly\": \"npm run build && npm run test && npm run lint\",\n    \"start\": \"node dist/index.js\"\n  },\n  \"keywords\": [\n    \"mcp\",\n    \"mcp-server\",\n    \"portal-da-transparencia\",\n    \"api\",\n    \"typescript\",\n    \"brasil\",\n    \"governo\",\n    \"transparency\"\n  ],\n  \"author\": \"Your Name\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/yourusername/mcp-portal-transparencia.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/yourusername/mcp-portal-transparencia/issues\"\n  },\n  \"homepage\": \"https://github.com/yourusername/mcp-portal-transparencia#readme\",\n  \"engines\": {\n    \"node\": \">=16.0.0\"\n  }\n}\n```\n2. Create .npmignore file:\n```\nsrc/\ntests/\nexamples/\n.github/\n.vscode/\n.eslintrc.js\n.prettierrc\ntsconfig.json\njest.config.js\ntypedoc.json\n.gitignore\n.env\n.env.example\ncoverage/\ndocs/\n```\n3. Ensure dist/index.js has proper shebang for CLI usage:\n```javascript\n#!/usr/bin/env node\n```\n4. Create release workflow in GitHub Actions:\n```yaml\nname: Release\n\non:\n  release:\n    types: [created]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n        with:\n          node-version: '16.x'\n          registry-url: 'https://registry.npmjs.org/'\n      - run: npm ci\n      - run: npm run build\n      - run: npm run test\n      - run: npm publish\n        env:\n          NODE_AUTH_TOKEN: ${{secrets.NPM_TOKEN}}\n```\n5. Create CHANGELOG.md for version tracking\n6. Add LICENSE file (MIT)\n7. Configure semantic versioning for releases\n8. Add README section explaining npx usage for MCP server",
        "testStrategy": "1. Verify package builds correctly with executable permissions\n2. Test installation and execution via npx mcp-portal-transparencia\n3. Verify MCP server starts correctly when run via npx\n4. Test TypeScript types are correctly included\n5. Check that unnecessary files are excluded\n6. Test package.json scripts\n7. Verify bin configuration works properly",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Create CI/CD Pipeline",
        "description": "Set up basic continuous integration and deployment pipeline for automated testing, building, and publishing.",
        "status": "pending",
        "dependencies": [
          1,
          13,
          14,
          15,
          17
        ],
        "priority": "medium",
        "details": "1. Create GitHub Actions workflow for CI in `.github/workflows/ci.yml`:\n```yaml\nname: CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js 18.x\n      uses: actions/setup-node@v3\n      with:\n        node-version: 18.x\n    - run: npm ci\n    - run: npm run test\n\n  build-and-publish:\n    runs-on: ubuntu-latest\n    if: github.event_name == 'push' && github.ref == 'refs/heads/main'\n    needs: test\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js 18.x\n      uses: actions/setup-node@v3\n      with:\n        node-version: 18.x\n        registry-url: 'https://registry.npmjs.org'\n    - run: npm ci\n    - run: npm run build\n    - run: npm publish\n      env:\n        NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n```\n2. Configure basic branch protection rules:\n   - Require pull request reviews before merging\n   - Require status checks to pass before merging\n3. Set up NPM_TOKEN secret for publishing",
        "testStrategy": "1. Verify CI workflow runs tests on pull requests\n2. Test that branch protection prevents direct pushes to main\n3. Verify build and publish workflow runs on main branch pushes\n4. Test that publishing works with a test release",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement MCP Server Bridge for Portal da Transparência API",
        "description": "Create a complete MCP server that dynamically generates tools from the Portal da Transparência Swagger specification and provides seamless integration with Claude Desktop, Cursor, and other MCP-compatible UIs.",
        "details": "1. Create the main MCP server entry point in `src/mcp-server.ts`:\n```typescript\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport { SwaggerLoader } from './core/swagger-loader';\nimport { Authentication } from './core/authentication';\nimport { Logger } from './logging/logger';\nimport { OpenAPI } from 'openapi-types';\n\nexport class MCPPortalServer {\n  private server: Server;\n  private swaggerLoader: SwaggerLoader;\n  private auth: Authentication;\n  private logger: Logger;\n  private tools: Map<string, any> = new Map();\n\n  constructor() {\n    this.logger = new Logger({ level: 'info' });\n    this.server = new Server({\n      name: 'portal-transparencia-mcp',\n      version: '1.0.0'\n    }, {\n      capabilities: {\n        tools: {}\n      }\n    });\n    this.swaggerLoader = new SwaggerLoader('https://api.portaldatransparencia.gov.br/swagger-ui/swagger.json', this.logger);\n    this.auth = new Authentication({}, this.logger);\n  }\n\n  async initialize(): Promise<void> {\n    const spec = await this.swaggerLoader.loadSpec();\n    await this.generateToolsFromSpec(spec);\n    this.setupToolHandlers();\n  }\n\n  private async generateToolsFromSpec(spec: OpenAPI.Document): Promise<void> {\n    // Generate MCP tools for each endpoint\n    for (const [path, pathItem] of Object.entries(spec.paths || {})) {\n      for (const [method, operation] of Object.entries(pathItem || {})) {\n        if (typeof operation === 'object' && operation.operationId) {\n          const toolName = this.generateToolName(operation.operationId, method, path);\n          const tool = this.createMCPTool(operation, method, path);\n          this.tools.set(toolName, tool);\n        }\n      }\n    }\n  }\n\n  private createMCPTool(operation: any, method: string, path: string) {\n    return {\n      name: this.generateToolName(operation.operationId, method, path),\n      description: operation.summary || operation.description || `${method.toUpperCase()} ${path}`,\n      inputSchema: this.generateInputSchema(operation.parameters || []),\n      handler: async (args: any) => {\n        return await this.executeApiCall(method, path, operation, args);\n      }\n    };\n  }\n\n  private async executeApiCall(method: string, path: string, operation: any, args: any): Promise<any> {\n    try {\n      // Build URL with path parameters\n      let url = `https://api.portaldatransparencia.gov.br/api-de-dados${path}`;\n      const pathParams = operation.parameters?.filter((p: any) => p.in === 'path') || [];\n      \n      for (const param of pathParams) {\n        if (args[param.name]) {\n          url = url.replace(`{${param.name}}`, encodeURIComponent(args[param.name]));\n        }\n      }\n\n      // Build query parameters\n      const queryParams = operation.parameters?.filter((p: any) => p.in === 'query') || [];\n      const searchParams = new URLSearchParams();\n      \n      for (const param of queryParams) {\n        if (args[param.name] !== undefined) {\n          searchParams.append(param.name, args[param.name]);\n        }\n      }\n\n      if (searchParams.toString()) {\n        url += `?${searchParams.toString()}`;\n      }\n\n      // Make API call with authentication\n      const headers = this.auth.getHeaders();\n      const response = await fetch(url, {\n        method: method.toUpperCase(),\n        headers\n      });\n\n      if (!response.ok) {\n        throw new Error(`API call failed: ${response.status} ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      return {\n        success: true,\n        data,\n        metadata: {\n          endpoint: `${method.toUpperCase()} ${path}`,\n          status: response.status,\n          headers: Object.fromEntries(response.headers.entries())\n        }\n      };\n    } catch (error) {\n      this.logger.error('API call failed', { error: error.message, method, path, args });\n      return {\n        success: false,\n        error: error.message,\n        endpoint: `${method.toUpperCase()} ${path}`\n      };\n    }\n  }\n\n  async start(): Promise<void> {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n    this.logger.info('MCP Portal da Transparência server started');\n  }\n}\n```\n\n2. Create CLI executable in `bin/mcp-portal-server.js`:\n```javascript\n#!/usr/bin/env node\nconst { MCPPortalServer } = require('../dist/mcp-server.js');\n\nasync function main() {\n  const server = new MCPPortalServer();\n  await server.initialize();\n  await server.start();\n}\n\nmain().catch(console.error);\n```\n\n3. Update package.json for npx compatibility:\n```json\n{\n  \"bin\": {\n    \"mcp-portal-server\": \"./bin/mcp-portal-server.js\"\n  },\n  \"files\": [\n    \"dist/\",\n    \"bin/\"\n  ]\n}\n```\n\n4. Create configuration guide in `docs/mcp-setup.md` for Claude Desktop, Cursor, and other UIs with specific configuration examples.\n\n5. Implement comprehensive error handling with user-friendly messages and automatic retry logic for common failures.\n\n6. Add tool categorization and filtering capabilities to organize the large number of endpoints into logical groups.",
        "testStrategy": "1. Unit tests for MCP server components:\n   - Test tool generation from Swagger spec\n   - Test parameter mapping and validation\n   - Test authentication header injection\n   - Test error handling and user-friendly error messages\n   - Test tool categorization and filtering\n\n2. Integration tests with MCP protocol:\n   - Test server initialization and tool registration\n   - Test tool execution with mock API responses\n   - Test stdio transport communication\n   - Test with actual Portal da Transparência API endpoints\n   - Verify all generated tools are accessible and functional\n\n3. End-to-end testing with MCP clients:\n   - Test installation via npx\n   - Test configuration with Claude Desktop\n   - Test configuration with Cursor\n   - Test tool discovery and execution in actual UI environments\n   - Verify user experience is smooth and error messages are helpful\n\n4. Performance and reliability tests:\n   - Test server startup time with large Swagger spec\n   - Test memory usage with many registered tools\n   - Test concurrent tool execution\n   - Test error recovery and graceful degradation\n   - Test with rate limiting scenarios",
        "status": "done",
        "dependencies": [
          1,
          2,
          4
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup básico do MCP Server com SDK",
            "description": "Criar a estrutura básica do MCP server usando o SDK oficial, configurar transporte stdio e definir capabilities do servidor",
            "details": "- Instalar @modelcontextprotocol/sdk\n- Criar classe MCPPortalServer básica\n- Configurar Server e StdioServerTransport\n- Definir capabilities (tools)\n- Implementar métodos de inicialização e start\n- Configurar logging básico",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 19
          },
          {
            "id": 2,
            "title": "Integração com Swagger Loader",
            "description": "Integrar o SwaggerLoader existente com o MCP server para carregar dinamicamente a especificação do Portal da Transparência",
            "details": "- Instanciar SwaggerLoader no MCP server\n- Carregar spec do Portal da Transparência na inicialização\n- Implementar cache da spec para evitar recarregamentos\n- Tratar erros de carregamento da spec\n- Validar estrutura da spec carregada",
            "status": "done",
            "dependencies": [
              "19.1"
            ],
            "parentTaskId": 19
          },
          {
            "id": 3,
            "title": "Geração Dinâmica de Tools MCP",
            "description": "Implementar sistema que converte automaticamente cada endpoint da API em uma ferramenta MCP utilizável pelo Claude",
            "details": "- Iterar sobre paths e operations do Swagger spec\n- Gerar nomes únicos e descritivos para cada tool\n- Criar input schemas baseados nos parâmetros da API\n- Mapear parâmetros de path, query e body\n- Categorizar tools por tags/grupos\n- Registrar tools no MCP server\n- Validar schemas gerados",
            "status": "done",
            "dependencies": [
              "19.2"
            ],
            "parentTaskId": 19
          },
          {
            "id": 4,
            "title": "Sistema de Execução de API Calls",
            "description": "Implementar o executor que transforma chamadas de tools MCP em requests HTTP para a API do Portal da Transparência",
            "details": "- Implementar método executeApiCall\n- Construir URLs com parâmetros de path substituídos\n- Montar query parameters dinamicamente\n- Integrar headers de autenticação\n- Fazer requests HTTP (fetch/axios)\n- Tratar respostas e formatá-las para o MCP\n- Implementar retry logic básico\n- Retornar dados + metadata da resposta",
            "status": "done",
            "dependencies": [
              "19.3"
            ],
            "parentTaskId": 19
          },
          {
            "id": 5,
            "title": "CLI Setup para NPX",
            "description": "Criar executável CLI que permite rodar o MCP server via npx de forma simples e direta",
            "details": "- Criar bin/mcp-portal-transparencia executável\n- Adicionar shebang #!/usr/bin/env node\n- Configurar package.json bin field\n- Implementar CLI que instancia e inicia o server\n- Adicionar parsing de argumentos básicos (API key, port, etc)\n- Tratar erros de inicialização gracefully\n- Adicionar help e version commands",
            "status": "done",
            "dependencies": [
              "19.4"
            ],
            "parentTaskId": 19
          },
          {
            "id": 6,
            "title": "Sistema de Autenticação Integrado",
            "description": "Integrar o sistema de autenticação existente com o MCP server para gerenciar API keys automaticamente",
            "details": "- Integrar Authentication class no MCP server\n- Carregar API key de variáveis de ambiente\n- Implementar configuração via CLI arguments\n- Adicionar headers de autenticação em todas as requests\n- Validar se API key está configurada\n- Fornecer mensagens de erro claras sobre autenticação\n- Suportar configuração per-tool se necessário",
            "status": "done",
            "dependencies": [
              "19.1"
            ],
            "parentTaskId": 19
          },
          {
            "id": 7,
            "title": "Error Handling User-Friendly",
            "description": "Implementar sistema de tratamento de erros que fornece mensagens claras e úteis para usuários finais do Claude/Cursor",
            "details": "- Capturar e classificar diferentes tipos de erro da API\n- Traduzir erros HTTP em mensagens user-friendly\n- Implementar fallbacks para erros de rede\n- Adicionar sugestões de resolução nos erros\n- Logar erros para debugging sem expor ao usuário\n- Tratar casos especiais (rate limiting, auth failures)\n- Formatar erros no padrão MCP",
            "status": "done",
            "dependencies": [
              "19.4",
              "19.6"
            ],
            "parentTaskId": 19
          },
          {
            "id": 8,
            "title": "Organização e Categorização de Tools",
            "description": "Implementar sistema para organizar e categorizar as centenas de tools geradas, facilitando descoberta e uso pelo Claude",
            "details": "- Agrupar tools por categorias (servidores, contratos, viagens, etc)\n- Criar nomes de tools descritivos e consistentes\n- Implementar prefixos/sufixos organizacionais\n- Adicionar descrições detalhadas para cada tool\n- Implementar sistema de tags/metadata\n- Criar lista/comando help para descobrir tools\n- Otimizar ordem de apresentação das tools\n- Documentar padrões de naming",
            "status": "done",
            "dependencies": [
              "19.3"
            ],
            "parentTaskId": 19
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-06T19:43:37.348Z",
<<<<<<< HEAD
      "updated": "2025-07-08T15:18:32.240Z",
=======
      "updated": "2025-07-07T19:55:38.375Z",
>>>>>>> develop
      "description": "Tasks for master context"
    }
  }
}